Full-Stack Engineer (.NET 10 / Next.js) AI-Assisted Build
Test (90 Minutes)
Purpose
This test is intentionally designed to allow and encourage the use of AI tools (ChatGPT,
Claude Code, Copilot, Cursor, etc.).
We are evaluating: - How you think and prioritize under a strict timebox - How you prompt
AI and critique its output - How you turn AI assistance into shippable, maintainable code -
Multi-tenant / multi-branch design maturity (Thailand-first, global-ready)
We are not testing memorization.
Timebox
⏱ 90 minutes (strict) - You are not expected to finish everything - Trade-offs are expected
- Over-engineering is discouraged - Correct boundaries > feature count
Scenario
You are building v1 of a Clinic POS platform.
This is a multi-tenant, multi-branch B2B system: - 1 Tenant → many Branches - 1 Patient
belongs to exactly 1 Tenant, and may visit multiple Branches - Tenant data isolation is
mandatory (no cross-tenant exposure)
You are not required to implement enterprise-grade tenancy enforcement, but your design
must be tenant-safe by default.
Technology constraints (mandatory)
• Backend: .NET 10 / C#
• Frontend: Next.js
• Database: PostgreSQL
• Cache: Redis
• Messaging: RabbitMQ
What makes this test
We are looking for candidates who can ship a thin vertical slice with: - Clear domain
boundaries - Correctness under concurrency - Tenant-safe data access patterns - Minimal
but meaningful automated tests - Runnability on another machine with one command
If you try to build “everything”, you will fail the timebox.
Task set — You have 90 minutes
You must complete ALL of Section A + Section B and ANY TWO of Section C / D / E.
Strong candidates will also include a small test suite and a clean runbook.
Section A — Core slice (mandatory)
A1. Implement a working thin slice (backend + frontend)
Build a usable flow end-to-end: - Create Patient - List Patients
Minimum backend requirements
• REST API with request validation and consistent error responses
• Persistence in PostgreSQL (migrations required)
• Tenant-safe filtering on all reads/writes
Minimum frontend requirements
• Next.js UI that can:
o Create a patient
o List patients
o Filter by Branch (optional)
• Basic usability: fast, simple forms; no heavy UI work required
A2. Create Patient
Patient fields (minimum): - FirstName (required) - LastName (required) - PhoneNumber
(required) - TenantId (required) - CreatedAt (server-generated) - (Optional)
PrimaryBranchId
Rules: - PhoneNumber must be unique within the same Tenant (not globally) - Return a
safe error on duplicate
A3. List Patients
List with: - Required filter: TenantId - Optional filter: BranchId - Sorted by CreatedAt DESC
You may model “patient visits branches” minimally (e.g., PrimaryBranchId or a
separate mapping table). Explain your choice.
Section B — Authorization & user management
(mandatory)
B1. Roles
Implement role-based permissions: - Admin - User - Viewer
B2. Permissions (minimum)
Define and enforce permissions for: - Creating patients - Viewing patients - Creating
appointments (even if you don’t implement appointments)
B3. User management (minimal scope)
Implement API endpoints: - Create User - Assign Role - Associate User with Tenant and one
or more Branches
Required enforcement
• Requests must include an authenticated identity (choose JWT, cookie session, or
simple token)
• Authorization must be enforced server-side (policy/attribute/middleware)
• Viewer cannot create patients
Stubbing auth is acceptable only if permissions are still enforced reliably.
B4. Seeder (required)
Provide a seeder that creates: - 1 Tenant - 2 Branches - Users for each role (Admin, User,
Viewer) - Correct tenant/branch associations
Seeder must be runnable via one command.
Section C — Appointment + messaging (choose any two
sections total)
C1. Create Appointment
Implement Create Appointment with: - TenantId, BranchId, PatientId - StartAt (datetime) -
CreatedAt
C2. Prevent exact duplicate booking
Prevent duplicates within the same Tenant for: - Same PatientId + same StartAt + same
BranchId
Must be safe under concurrency (prefer DB unique constraint + friendly error).
C3. Publish event to RabbitMQ
Publish an event when appointment is created: - Event name of your choice - Payload must
include TenantId
Consumer is optional.
Section D — Caching & data access (choose any two
sections total)
D1. Cache at least one read path
Cache List Patients (or another meaningful GET).
D2. Cache key strategy for tenant isolation
Keys must be tenant-scoped (e.g., tenant:{tenantId}:patients:list:{branchId|all})
D3. Invalidation
On Create Patient (and Create Appointment if implemented): - Invalidate relevant cache
keys - Or use versioned keys with tenant-scoped version bump